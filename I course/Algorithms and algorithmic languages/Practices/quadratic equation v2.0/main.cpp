// Понятие класса как основного инструмента абстрагирования и инкапсуляции
#include <iostream>
#include <cmath>
using namespace std;
// класс - тип данных, описывающий модель объекта предметной области
// модель включает структурные свойства (из чего состоит объект) и поведенческие свойсва (какие операции можно с объектом сделать)
// объявление класса - описание модели
class Equation {
// структурные свойства
// обычно имеют уровень доступ private (по умолчанию), так как их открытие внешней среде приводит к возможности неконтролируемого изменения
    double a,b,c; // коэффициенты квадратного уравнения
    double x1,x2; // в уравнении может быть максимум 2 корня
    int count; // переменная для разграничения ситуаций, какое количество корней будет у уравнения
// поведенческие свойства
// большинство поведенческих свойств обычно открыты внешней среде (уровень доступа public), так как
// они обеспечивают интерфейс взаимодействия с внешней средой (другими объектами и функциями)
public:
// конструктор - создает и корректно инициализирует объект. Объект всегда должен быть в целостном состоянии
    Equation(double a, double b, double c);
    ~Equation(); // деструктор - корректно уничтожает объект
// методы получения решения уравнения - печать или получение корней по частям
    void PrintSolution();
    double GetX1();
    double GetX2();
private:
// метод решения уравнения - находится в секции private, так как выделен для корректной структуризации алгоритма (не перемешивать инициализацию и решение)
// будет вызываться из конструктора, чтобы уравнение всегда находилось в решенном состоянии
    void Solve();
};

// конструктор
// при определении метода за пределами объявления класса следует пользоваться полным именем - имя класса::имя метода
Equation::Equation(double a, double b, double c) {
// обработка исключений - некорректные входные данные должны обрабатываеться конструктором так, чтобы объект не создавался
// исключительная ситуация - это аварийный с точки зрения хода управления программы выход из метода, некорректное завершение, которое можно в дальнейшем программно обработать
    if (a==0 && b==0 && c!=0)
        throw 1;
// при корректных параметрах сохраняем значения параметров в переменных класса
// при наличии повторения имени в параметрах и переменных класса обращение просто по имени будет применяться к параметрам метода (их время жизни меньше, поэтому они считаются важнее)
// при обращении к переменным класса следует использовать ключевое слово this - неявное структурное свойство (переменная) всех классов, которая хранит адрес памяти, по которому находится текущий объект
    this->a=a;this->b=b; this->c=c;
// вызов метода решения уравнения для инициализации структурных свойств, которые указывают на решение уравнения (x1, x2, count)
    Solve();
}

// деструктор вызывается автоматически при уничтожении объекта. Явно деструктор не вызывают
Equation::~Equation() {
    cout<<"Уравнение уничтожено"<<endl;
}

// метод печати решения уравнения
void Equation::PrintSolution() {
    switch(count) {
        case 0: cout<<"Комплексные корни"<<endl; break;
        case 1: cout<<"x1="<<x1<<endl; break;
        case 2: cout<<"x1="<<x1<<" x2="<<x2<<endl; break;
        case 3: cout<<"Любое x - корень"<<endl;
    }
}

// метод получения первого корня уравнения при его наличии
double Equation::GetX1() {
// контроль - имеется ли у уравнения первый корень - на это указывает переменная количества корней
    if(count==1 || count==2)
        return x1;
// если корня 1 нет, то возвращать нечего. Но метод должен вернуть значение типа double. Поэтому генерируем исключительную ситуацию
// для аварийного выхода из метода
    throw 2;
}

// метод получения второго корня уравнения при его наличии
double Equation::GetX2() {
    if(count==2)
        return x2;
    throw 2;
}

// метод решения уравнения
void Equation::Solve() {
// решение определяется на основе анализа значений коэффициентов уравнения
    if(a==0)
        if(b==0)
            count=10;
        else {
            count=1;
            x1=-c/b;
        }
    else {
// дискриминант - операционная переменная. Он нужен только для определения корней, другой информации не несет.
// поэтому он не выделен как структурное свойство, а введен в методе, где он действительно нужен.
        double d=b*b-4*a*c;
        if(d>=0) {
            count=2;
            x1=(-b+sqrt(d))/(2*a);
            x2=(-b-sqrt(d))/(2*a);
        }
        else
            count=0;
    }
}

int main() {
    setlocale(LC_ALL, "ru");
// если внутри фрагмента программного кода может возникнуть исключительная ситуация,
// то этот фрагмент для корректной обработки следует поместить в блок try (попытка выполнить код)
// если исключений не возникнет, управление передается дальше
// если исключение возникнет, то управление передается в блок catch, следующий непосредственно за блоком try
// блоков catch модет быть несколько - они отличаются типом данных исключительных ситуаций
// управление передается только в блок с соответствующим типом
// если такого блока catch нет, программа будет аварийно завершена
    try {
        Equation eq(10,1,1);
        eq.PrintSolution();
        //cout<<"x1="<<eq.GetX1()<<" x2="<<eq.GetX2()<<endl;
    }

    catch (int er) {
        switch(er) {
            case 1: cout<<"Ошибка задания уравнения"<<endl; break;
            case 2: cout<<"Обращение к несуществующему корню"<<endl;
        }
    }
    return 0;
}