import random
class RSA():
    def __init__(self):
        (self.e, self.n), self.d = self.generate_keys()

    def mod_exp(self, base: int, exp: int, mod: int) -> int:
        """
        Быстрое возведение в степень по модулю.
        base - основание
        exp - показатель степени
        mod - модуль
        """
        # Особый случай - при модуле 1 всегда получаем 0
        # Любое число по модулю 1 всегда дает 0
        if mod == 1:
            return 0

        # Начальное значение результата
        result = 1
        # Приводим базу по модулю для оптимизации
        base = base % mod

        # Пока показатель степени не станет равным 0
        while exp > 0:
            # Если текущий бит показателя равен 1
            # (проверяем с помощью побитового И)
            if exp & 1:
                # Умножаем результат на текущую базу
                result = (result * base) % mod

            # Возводим базу в квадрат для следующей итерации
            base = (base * base) % mod
            # Сдвигаем показатель вправо (делим на 2)
            exp >>= 1

        return result


    def miller_rabin(self, n, k=40):
        """
        Тест Миллера-Рабина на простоту числа.
        Вероятностный тест - может ошибаться с вероятностью не более 4^(-k)

        Args:
            n: Тестируемое число
            k: Количество раундов тестирования (больше k = выше точность)

        Returns:
            bool: True если число вероятно простое, False если составное
        """
        # Проверяем базовые случаи
        if n == 2:  # 2 - простое число
            return True
        if not n & 1 or n < 2:  # Четные числа кроме 2 и числа < 2 не простые
            return False

        # Нужно найти s такое, что n-1 = d * 2^s
        # Представляем n-1 в виде d * 2^s, где d нечетное
        s = 0  # Степень двойки
        d = n - 1  # Нечетный множитель
        while not d & 1:  # Пока d четное
            s += 1
            d >>= 1  # Делим d на 2

        # Проводим k раундов тестирования
        for _ in range(k):
            # Выбираем случайное a из [2, n-1]
            a = random.randrange(2, n - 1)

            # Вычисляем x = a^d mod n
            x = self.mod_exp(a, d, n)

            # Если x = 1 или x = n-1, этот раунд пройден
            if x == 1 or x == n - 1:
                continue

            # Возводим x в квадрат s-1 раз и проверяем, что результат -1
            for _ in range(s - 1):
                x = self.mod_exp(x, 2, n)
                # Если получили -1, раунд пройден
                if x == n - 1:
                    break
            # Если не нашли -1, число составное
            else:
                return False

        # Если все тесты пройдены, число вероятно простое
        return True


    def generate_prime(self,bits):
        """
        Генерация простого числа заданной битовой длины.

        Args:
            bits: Требуемая длина числа в битах

        Returns:
            Простое число длиной bits бит
        """
        while True:
            # Генерируем случайное число длиной bits
            # random.getrandbits(bits) дает случайную битовую строку
            # | (1 << bits - 1) устанавливает старший бит в 1 (гарантирует длину)
            # | 1 устанавливает младший бит в 1 (делает число нечетным)
            p = random.getrandbits(bits) | (1 << bits - 1) | 1

            # Проверяем число на простоту тестом Миллера-Рабина
            # Если тест пройден - возвращаем число
            if self.miller_rabin(p):
                return p


    def gcd(self, a, b):
        """Наибольший общий делитель."""
        while b:
            a, b = b, a % b
        return a


    def extended_gcd(self, a, b):
        """
        a * a^-1 = 1
        Расширенный алгоритм Евклида.
        Находит НОД(a,b) и коэффициенты Безу x,y такие что:
        ax + by = НОД(a,b)

        Args:
            a, b: Целые числа
        Returns:
            (gcd, x, y): НОД и коэффициенты Безу
        """
        # Базовый случай рекурсии
        if a == 0:
            return b, 0, 1

        # Рекурсивный вызов с уменьшенными значениями
        # b % a - остаток от деления b на a
        gcd, x1, y1 = self.extended_gcd(b % a, a)

        # Вычисляем коэффициенты x и y
        # на основе полученных x1, y1
        x = y1 - (b // a) * x1
        y = x1

        return gcd, x, y


    def modinv(self, a, m):
        """
        Нахождение мультипликативного обратного по модулю.
        Находит число x такое, что (a * x) % m = 1

        Args:
            a: Число, для которого ищем обратное
            m: Модуль

        Returns:
            x: Мультипликативно обратное число

        Raises:
            ValueError: Если обратное не существует
        """
        # Используем расширенный алгоритм Евклида
        # для поиска коэффициентов x,y: ax + my = НОД(a,m)
        gcd, x, _ = self.extended_gcd(a, m)

        # Обратное существует только если НОД(a,m) = 1
        # (числа взаимно простые)
        if gcd != 1:
            raise ValueError("Мультипликативное обратное не существует")

        # Приводим x по модулю m, чтобы получить
        # положительное число в диапазоне [0, m-1]
        return x % m


    def generate_keys(self, bits=512):
        """
        Генерация пары ключей RSA (открытого и закрытого).

        План генерации:
        1. Генерируем два больших простых числа p и q
        2. Вычисляем их произведение n = p*q
        3. Вычисляем функцию Эйлера phi = (p-1)(q-1)
        4. Подбираем открытую экспоненту e
        5. Вычисляем закрытую экспоненту d
        """
        # Генерируем два случайных простых числа длиной bits
        p = self.generate_prime(bits)  # Первое простое число
        q = self.generate_prime(bits)  # Второе простое число

        # Вычисляем модуль n = p*q
        n = p * q

        # Вычисляем значение функции Эйлера: phi = (p-1)(q-1)
        # Нужно для нахождения закрытой экспоненты d
        phi = (p - 1) * (q - 1)

        # Длина открытой экспоненты e = 1/3 от длины модуля
        # для оптимального баланса безопасности и скорости
        e_bits = bits // 3
        # Ограничиваем e сверху минимумом из phi и 2^e_bits
        max_e = min(phi, 1 << e_bits)

        # Подбираем случайное e, взаимно простое с phi
        e = random.randint(1, max_e)
        while self.gcd(e, phi) != 1:  # Проверяем взаимную простоту
            e = random.randint(1, max_e)

        # Вычисляем закрытую экспоненту d
        # как мультипликативно обратное к e по модулю phi
        d = self.modinv(e, phi)

        # Возвращаем пару ((e,n), d):
        # (e,n) - открытый ключ
        # d - закрытый ключ
        return (e, n), d
