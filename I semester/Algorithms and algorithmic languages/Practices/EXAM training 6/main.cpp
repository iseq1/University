#include <iostream>
#include <stack>

using namespace std;

// работа с бинарными деревьями сортировки

class Tree {
// структура одного узла бинарного дерева (два потомка)
    struct Node{
        int info;
        Node* left; // ссылка на левый потомок - туда помещаются элементы, меньшие info
        Node* right; // ссылка на правый потомок - туда помещаются элементы, большие или равные info
        Node (int info){ this->info=info; left=right= nullptr;} // создаются только листовые узлы дерева - узлы, у которых нет потомков
    };

// корень дерева

    Node* main_root;
public:
    Tree();
// нерекурсивный вариант функции добавления элемента в дерево
    void Add_1(int info);
// функция-адаптер для рекурсивного варианта функции добавления элемента в дерево
    void Add_2(int info);
// функция-адаптер для рекурсивного варианта функции печати элементов дерева
    void Print_2();

    void IsRepeatingElemExmpl();
    void IsRepeatingElem();


private:
// рекурсивные функции являются private-функциями, так как они по сути реализуют алгоритм и объект им нужен как хранилище данных
// кроме того, параметры рекурсивной функции (ссылка на корень поддерева) фактически нарушают инкаплусяцию в случае видимости извне
// рекурсивная функция добавления элемента в дерево (поддерево) с корнем root
    void Add_2(int info, Node*& root);
// рекурсивная функция печати элеметов дерева
    void Print_2(Node* root);
};

// конструктор создает пустое дерево

Tree::Tree(){
    main_root=NULL;
}


void Tree::IsRepeatingElemExmpl() {
// для возврата на верхние узлы дерева требуется стек
    stack<Node*> s;
// начинаем проход с корневого узла дерева
    Node* cur=main_root;
// пока не кончатся узлы, осуществляем перебор
// узлы закончатся, когда дойдем до конца ветви и некуда будет возвращаться (стек окажется пустым)
    while(!s.empty() || cur!=NULL) {
// двигаемся по самой левой ветви до ее конца
        while(cur!=NULL) {
// каждый пройденный узел помещается в стек
            s.push(cur);
// сдвигаемся дальше по самой левой ветви
            cur=cur->left;
        }
// дошли до конца ветви, требуется вернуться на предыдущий узел,
// чтобы переместиться на правого потомка
// считываем последний пройденный узел из стека
        cur=s.top(); s.pop();
// печать информации из узла
        cout<<cur->info<<" ";
// передвижение на правого потомка - его обработкой заканчивается обработка поддерева
        cur=cur->right;
    }
    cout<<endl;
}







void Tree::IsRepeatingElem() {
    stack<Node*>roots;
    stack<Node*>s;
    Node*cur;
    cur=main_root;
    while(!s.empty() || cur!= nullptr){
        while(cur!= nullptr){
            s.push(cur);
            cur=cur->left;
        }
        cur=s.top(); s.pop();
        roots.push(cur);
        cur=cur->right;
    }
    int size=roots.size();
    int* mas=new int[roots.size()]; int i=0;
    while(!roots.empty()){
        cur=roots.top(); roots.pop();
        mas[i]=cur->info; i++;
    }

    int k=0, kmax=0, repitmax=0;
    while (k!=size){
        int repit=0;
        for(int j=0; j<size-k; j++){
            if (mas[k]==mas[j]){
                repit++;
            }
        }
        if(repit>1){
            kmax=mas[k]; repitmax=repit;
        }
        k++;
    }

    if (kmax!=0){
        cout<<"The tree has a repeating root: "<<kmax<<" - "<<repitmax<<" times!"<<endl;
    }
    else cout<<"The tree has not a repeating root"<<endl;
}























//функция-адаптер для рекурсивного варианта функции печати элементов дерева
void Tree::Print_2(){
// если дерево пустое, печатаем сообщение
    if (main_root==NULL)
        cout<<"Дерево пусто"<<endl;
    else
// для непустого дерева вызываем рекурсивную функцию для всего дерева (передаем корень всего дерева)
        Print_2(main_root);
}

// рекурсивная функция печати элементов поддерева с корнем root (обход ЛКП)

void Tree::Print_2(Node* root){
// явный случай - пустое дерево не печатаем
    if (root==NULL) return;
// сначала печатаем левое поддерево
    Print_2(root->left);
// печатаем значение в корне поддерева
    cout<<(root->info)<<" ";
// печатаем правое поддерево
    Print_2(root->right);
}

// функция-адаптер для алгоритма рекурсивного добавления элемента в дерево

void Tree::Add_2(int info){
// нерекурсивный вызов
    Add_2(info, main_root);
}

// рекурсивная функция добавления элемента в поддерево с корнем root (передается по ссылке, чтобы можно было новый узел сохранить)

void Tree::Add_2(int info, Node*& root){
// если поддерево пустое, создаем единственный узел (адрес сохранится в переменной, ссылка на которую передана в качестве параметра)
    if(root==NULL){
        root = new Node(info); return;
    }

// если значение должно быть в левом поддереве

    if(root->info > info)
// добавляем значение в левое поддерево
        Add_2(info, root->left);
    else
// добавляем значение в правое поддерево
        Add_2(info, root->right);
}

// нерекурсивный вариант функции добавления элемента в дерево
void Tree::Add_1(int info) {
// в пустое дерево добавляется единственный узел
    if(main_root==NULL) {
        main_root = new Node(info); return;
    }
//если дерево не пустое, требуется найти место встави, начиная с корня, пройдя по одной ветви дерева
    Node* cur=main_root;
// движение по дереву будем проводить до получения места вставки - количество шагов в этом случае неизвестно
    while(true) {
        if(cur->info > info)
// добавление производится в левое поддерево
            if(cur->left!=NULL)
// если левое поддерево не пусто, то сдвигаемся на корень левого поддерева
                cur=cur->left;
            else {
// если левое поддерево пусто, найдено место вставки
// создается новый элемент и подцепляется в виде левого потомка
                cur->left=new Node(info); return;
            }
        else
// добавление производится в правое поддерево
        if(cur->right!=NULL)
// если правое поддерево не пусто, то сдвигаемся на корень правого поддерева
            cur=cur->right;
        else {
// если правое поддерево пусто, найдено место вставки
// создается новый элемент и подцепляется в виде правого потомка
            cur->right=new Node(info); return;
        }
    }
}

int main() {
    Tree tree;
    int a[]={7,3,6,8,1,5,2,4,9,10};
    for(int i=0;i<9; i++)
        tree.Add_2(a[i]);
    tree.Print_2();
    cout<<endl;
    tree.IsRepeatingElem();
    return 0;
}