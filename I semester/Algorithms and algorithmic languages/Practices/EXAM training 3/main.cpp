#include <iostream>

#include <climits>

#include <queue>

#include <stack>

#include <list>

#include <vector>

using namespace std;

// работа с графами, построение, поиск кратчайших путей

// обход вершин графа

class Graph

{

    int m; // количество вершин

    int n; // количество ребер

// хранение графа осуществляется с помощью матрицы смежности

    int** a; // матрица смежности графа - элемент хранит информацию о смежности вершин

// матрица длин кратчайших путей - T[i][j] -длина кратчайшего пути из вершины i в вершину j

    int** T;

// матрица номеров первых вершин на кратчайших путях -

// H[i][j] - номер вершины, в которую нужно идти из вершины i, если нужно попасть в вершину j

    int** H;

public:

// служебные функции построения графа

    Graph(int m, int n);

    ~Graph();

// ввод графа осуществляется с помощью массива ребер

    void Input();

    void Print();


    // task
    void IsConnected();
    //task




// обход вершин графа в ширину

    list<int> PathOnWidth(int v);

// обход вершин графа в глубину

    list<int> PathOnDepth(int v);

// создание графа для тестирования

    void InputTest();

// метод для получения пути между двумя заданными вершинами begin и end.

// список вершин пути возвращается как результат функции

// в параметр len заносится длина найденного пути

    list<int> ShortestPath(int begin, int end, int& len);

// поиск кратчайшего пути между двумя заданными вершинами (алгоритм Дейекстра)

    list<int> ShortestPath_D(int begin, int end, int& len);

private:

// алгоритм поиска кратчайших путей между всеми парами вершин (Алгоритм Флойда)

    void Floyd();

};





//task
void Graph::IsConnected() {
    int* VertexState=new int[m];
    bool flag=false;
    int k=0;
    int finalcount=0;
    for(int i=0;i<m;i++){
        VertexState[i]=1; // all black
    }
    VertexState[0]=2; // its red

    do{
        flag= true;
        for(int i=0;i<m;i++){
            if(VertexState[i]==2){
                VertexState[i]=3;
                k=i;
                break;
            }
        }
        for(int i=0; i<m;i++){
            if(a[k][i]==1 && VertexState[i]==1){
                VertexState[i]==2;
            }
        }
        for(int i=0;i<m;i++){
            if(VertexState[i]==2){
                flag=false;
            }
        }
    } while(flag==false);

    for(int i=0;i<m;i++){
        if(VertexState[i]==1){
            finalcount++;
        }
    }

    if(finalcount==0){
        cout<<"Connected!";
    }
    else cout<<"Disconnected!";
}




















// поиск кратчайшего пути между двумя заданными вершинами (алгоритм Дейекстра)

list<int> Graph::ShortestPath_D(int begin, int end, int& len)

{

// массив помеченных вершин

    vector<bool> labels;

// массив длин найденных кратчайших путей (из вершины begin во все остальные)

    vector<int> lens;

// массив хранит номер вершины-предшественника концевой вершины на кратчайшем пути из вершины begin в i-ую

    vector<int> prevs;

// начальная инициализация массивов

    for(int i=0;i<m;i++)

    {

// вершины пока не просмотрены

        labels.push_back(false);

// длины кратчайших путей равны бесконечности

        lens.push_back(INT_MAX);

// так как не найдены пути, вершины-предшественника для концевой вершины пока нет

        prevs.push_back(-1);

    }

// текущая вершина - вершина начала пути

    int v=begin-1;

    labels[v]=true;

    lens[v]=0;

// флаг успешности нахождения кратчайшего пути

    bool f=false;

// осуществляем пересчет кратчайших путей - количество итераций неизвестно заранее

    while(true)

    {

// просмотриваем все непросмотренные смежные вершины с v, чтобы, возможно,

// скорректировать длины кратчайших путей через них

        for(int i=0;i<m;i++)

// вершина i смежна вершине v

            if(v!=i && a[v][i]!=INT_MAX)

// вершина должна быть непомеченной

                if(!labels[i])

// проверка того, что путь в i-ую вершину через вершину v короче уже найденного

                    if(lens[i] > lens[v]+a[v][i])

                    {

// корректируем длины кратчайших путей и вершину-предшественника

                        lens[i]= lens[v]+a[v][i];

                        prevs[i]=v;

                    }

// поиск вершины, куда следует пройти на следующей итерации

// выбираем вершину с минимальной длиной пути в нее среди непомеченных вершин

        int min=INT_MAX, imin=-1;

        for(int i=0;i<m;i++)

            if(!labels[i] && lens[i]<min)

            {

                min=lens[i];

                imin=i;

            }

// если минимум не изменился, то пути не найдено - выход из цикла

        if(imin==-1)

            break;

// дошли до конечной вершины пути - кратчайший путь найден - выход из цикла

        if(imin==end-1)

        {

            f=true; // путь найден - установка флага успешности выполнения операции

            break;

        }

// переход в вершину, которой соответствует минимальный найденный на текущий момент путь

        v=imin;

// делаем пометку, что эта вершина уже пройдена

        labels[v]=true;

    }

// формирование результата

    if(f)

    {

// длина найденного кратчайшего пути помещается в параметр

        len=lens[end-1];

// путь раскручиваем с конца, так как массив prevs хранит вершины-предшественники для всех концевых вершин

        list<int> path;

// для получения обратного порядка используем стек

        stack<int> s;

// текущая вершина - конец пути

        s.push(end); // помещаем ее в стек

        v=end-1;

// пока не достигнем начальной вершины пути, переходим к вершине-предшественнику

// и помещаем новую текущую вершину в стек

        while(v!=begin-1)

        {

            v=prevs[v];

            s.push(v+1);

        }

//переносим результаты в список-результат для получения маршрута

        while(!s.empty())

        {

            path.push_back(s.top()); s.pop();

        }

        return path;

    }

// если пути не найдено, генерируем исключение

    throw 1;

}

// алгоритм поиска кратчайших путей между всеми парами вершин (Алгоритм Флойда)

void Graph::Floyd()

{

// начальная инициализация

    for(int i=0; i<m;i++)

        for(int j=0;j<m; j++)

        {

// путь между i и j вершинами есть, когда есть ребро i->j

            T[i][j]=a[i][j];

            H[i][j] = a[i][j]==INT_MAX? -1: j+1;

        }

// делаем попытки вставить вершину i во все маршруты j->k

    for(int i=0;i<m;i++) // вершина, которую включаем в середину пути

// перебор маршрутов

        for(int j=0;j<m;j++) // начало маршрута

            for(int k=0; k<m;k++) // конец маршрута

// все вершины должны быть разными

// не нужны маршруты типа i->i

                if(i!=j && i!=k && j!=k)

// пробуем построить маршрут из j в к через вершину i

// если существуют оба маршрута j->i и i->k (их длины - не бесконечности),

// то, возможно через вершину i проехать быстрее

                    if(T[j][i]!=INT_MAX && T[i][k]!=INT_MAX)

// сравниваем длины уже имеющегося пути (T[j][k]) и суммарную длину пути, если

// сначала едем в i вершину, а уж потом в k (T[j][i]+T[i][k])

                        if(T[j][k]>T[j][i]+T[i][k])

                        {

// меняем данные о крайтчайшем пути

                            T[j][k]=T[j][i]+T[i][k];

// при таком пути первая вершина на пути из j в k будет той же,

// что и первая вершина из j в i (так как сначала едем в i)

                            H[j][k]=H[j][i];

                        }

}

// получение кратчайшего пути

list<int> Graph::ShortestPath(int begin, int end, int& len)

{

    list<int> result;

// длина хранится в матрице длин кратчайших путей

    len=T[begin-1][end-1];

// сам путь строится из матрицы H

// v - текущая вершина. Вначале она совпадает с начальной вершиной пути

    int v=begin;

// пока не достигли конца пути (вершина end при нумерации с 1)

    while(v!=end)

    {

// заносим текущую вершину в список

        result.push_back(v);

// сдвигаем текущую вершину на следующую за ней при пути в вершину end

        v=H[v-1][end-1];

    }

// конечную вершину тоже записываем в список результата

    result.push_back(v);

    return result;

}

// обход вершин графа в ширину

list<int> Graph::PathOnWidth(int v)

{

// массив для пометок просмотренных вершин

    vector<bool> labels;

    for(int i=0;i<m;i++)

        labels.push_back(false);

// очередь для определения последовательности обработки

    queue<int> q;

// список для формирования результата

    list<int> res;

// v - начальная вершина, с которой будет начинаться обход

// помечаем ее как просмотренную и помещаем в очередь

    q.push(v); labels[v]=true;

// процесс завершается, когда в очереди ничего не останется

    while(!q.empty())

    {

// извлекаем очередную вершину для обработки

        v=q.front(); q.pop();

// добавляем эту вершину в список-результат - корректируем на 1 номер, чтобы на вывод нумерация была не с 0

        res.push_back(v+1);

// все непросмотренные смежные вершины с текущей помещаем в очередь и помечаем

        for(int i=0;i<m;i++)

// проверка на то, что вершины не помечены, и что между текущей вершиной v и вершиной i нет связи

            if(!labels[i] && i!=v && a[v][i]!=INT_MAX)

            {

                q.push(i); labels[i]=true;

            }

    }

    return res;

}

// обход вершин графа в глубину

list<int> Graph::PathOnDepth(int v)

{

// массив для пометок просмотренных вершин

    vector<bool> labels;

    for(int i=0;i<m;i++)

        labels.push_back(false);

// стек для определения последовательности обработки

    stack<int> s;

// список для формирования результата

    list<int> res;

// v - начальная вершина, с которой будет начинаться обход

// помечаем ее как просмотренную и помещаем в стек

    s.push(v); labels[v]=true;

// процесс завершается, когда в стеке ничего не останется

    while(!s.empty())

    {

// извлекаем очередную вершину для обработки

        v=s.top(); s.pop();

// добавляем эту вершину в список-результат - корректируем на 1 номер, чтобы на вывод нумерация была не с 0

        res.push_back(v+1);

// все непросмотренные смежные вершины с текущей помещаем в стек и помечаем

        for(int i=0;i<m;i++)

// проверка на то, что вершины не помечены, и что между текущей вершиной v и вершиной i нет связи

            if(!labels[i] && i!=v && a[v][i]!=INT_MAX)

            {

                s.push(i); labels[i]=true;

            }

    }

    return res;

}

void Graph::InputTest()

{

    a[0][1]=4; a[0][2]=2;

    a[1][4]=3;a[2][0]=2;

    a[2][3]=2;a[2][4]=4;

    a[3][1]=1; a[3][5]=0;

    a[4][2]=4; a[4][5]=3;

    a[5][0]=10; a[5][3]=0; a[5][4]=3;

    Floyd();

}

// конструктор - основная часть - создание матрицы смежности

Graph::Graph(int m, int n)

{

    if(m<=0 || n<=0) throw 1;

    this->m=m; this->n=n;

    a=new int*[m];

    for(int i=0;i<m;i++)

    {

        a[i]=new int[m];

// инициализация бесконечными значениями

// кроме главной диагонали - на ней должны стоять 0, так как из вершины не

// надо перемещаться в нее же саму

        for(int j=0;j<m;j++)

            a[i][j]=i==j?0:INT_MAX;

    }

// создание матриц для хранения кратчайших путей

    T=new int*[m];

    H=new int*[m];
    for(int i=0;i<m;i++) {

        T[i]=new int[m];

        H[i]=new int[m];

    }

}

//деструктор

Graph::~Graph()

{

    for(int i=m-1;i>=0;i--)

    {

        delete [] T[i];

        delete [] H[i];

        delete [] a[i];

    }

    delete [] a;

    delete [] T;

    delete [] H;

}

// ввод информации о графе будем осуществлять с помощью воода массива ребер

void Graph::Input()

{

    for(int i=0;i<n;i++)

    {

// запрашиваем информацию о каждом ребре и устанавливаем

// соответствующие элементы матрицы смежности

        int begin, end;// len;

        int choice;

        cout<<"Введите "<<(i+1)<<" ребро:"<<endl;

        cout<<"начало:"; cin>>begin;

        cout<<"конец:"; cin>>end;

        //cout<<"Длина:"; cin>>len;

        cout<<"Ориентировано (да - 1,нет - 0):"; cin>>choice;

// задание значения длины дуги (однонаправленность) или ребра (если нет однонаправленности) в матрицу

        a[begin-1][end-1]=1; //len;

        if(choice==0)

            a[end-1][begin-1]=1; //len;

    }

    //Floyd();

}

// вывод матрицы смежности

void Graph::Print()

{

    cout<<"Граф:"<<endl;

    for(int i=0;i<m;i++)

    {

        for(int j=0;j<m;j++)

            if(a[i][j]!=INT_MAX)

                cout<<a[i][j]<<"\t";

            else

                cout<<"-"<<"\t";

        cout<<endl;

    }

    cout<<endl;

}

int main()

{
    setlocale(LC_ALL, "ru");

    Graph gr(4,4);

    //gr.InputTest();
    gr.Input();

    gr.Print();

// обход графа в ширину

    list<int> path=gr.PathOnWidth(3);

// просмотр пути обхода графа

// класс-итератор определяет способ просмотра списка наподобие индекса или указателя

// метод begin() получает итератор первого элемента

    list<int>::iterator p=path.begin();

// итератор нужно сдвигать до достижения итератора конца, который получается с помощью метода end()

    while(p!=path.end())

    {

// операция * позволяет получить информацию из элемента списка, на который указывает итератор

        cout<<(*p)<<" ";

        p++;

    }

    cout<<endl;

// обход графа в глубину

    path=gr.PathOnDepth(3);

// просмотр пути обхода графа

// класс-итератор определяет способ просмотра списка наподобие индекса или указателя

// метод begin() получает итератор первого элемента

    p=path.begin();

// итератор нужно сдвигать до достижения итератора конца, который получается с помощью метода end()

    while(p!=path.end())

    {

// операция * позволяет получить информацию из элемента списка, на который указывает итератор
        cout<<(*p)<<" ";

        p++;

    }


    gr.IsConnected();

    return 0;

}