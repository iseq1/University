#include <iostream>
#include <stack>
#include <queue>

using namespace std;

// работа с бинарными деревьями сортировки

class Tree {
// структура одного узла бинарного дерева (два потомка)
    struct Node{
        int info;
        Node* left; // ссылка на левый потомок - туда помещаются элементы, меньшие info
        Node* right; // ссылка на правый потомок - туда помещаются элементы, большие или равные info
        Node (int info){ this->info=info; left=right= nullptr;} // создаются только листовые узлы дерева - узлы, у которых нет потомков
    };

// корень дерева

    Node* main_root;


public:
    Tree();
// нерекурсивный вариант функции добавления элемента в дерево
    void Add_1(int info);
// функция-адаптер для рекурсивного варианта функции добавления элемента в дерево
    void Add_2(int info);
// функция-адаптер для рекурсивного варианта функции печати элементов дерева
    void Print_2();

    void NumPeakLevel(int level);





private:
// рекурсивные функции являются private-функциями, так как они по сути реализуют алгоритм и объект им нужен как хранилище данных
// кроме того, параметры рекурсивной функции (ссылка на корень поддерева) фактически нарушают инкаплусяцию в случае видимости извне
// рекурсивная функция добавления элемента в дерево (поддерево) с корнем root
    void Add_2(int info, Node*& root);
// рекурсивная функция печати элеметов дерева
    void Print_2(Node* root);


};

// конструктор создает пустое дерево

Tree::Tree(){
    main_root= nullptr;
}









void Tree::NumPeakLevel(int level) {
    queue<Node*>peaks;
    peaks.push(main_root);
    int pass=1  ; int i=1; int k=0; int stage=1; //int peak=1;
    if(level==stage){
        cout<<"level \""<<level<<"\" has only "<<peaks.size()<<" vertex!";
    }

    while(!peaks.empty()){
        pass++;
        Node*cur=peaks.front();
        peaks.pop();
        if(cur->left!= nullptr){
            peaks.push(cur->left);
        }
        else k++;
        if(cur->right!= nullptr){
            peaks.push(cur->right);
        }
        else k++;

        if (pass == pow(2, i)){
            if (pass==pow(2,level-1)){
                cout<<"level \""<<level<<"\" has only "<<peaks.size()<<" vertex!";
            }
            i++;
            pass=pass+k;
           // peak+=peaks.size();
        }
    }
}

















//функция-адаптер для рекурсивного варианта функции печати элементов дерева
void Tree::Print_2(){
// если дерево пустое, печатаем сообщение
    if (main_root==NULL)
        cout<<"Дерево пусто"<<endl;
    else
// для непустого дерева вызываем рекурсивную функцию для всего дерева (передаем корень всего дерева)
        Print_2(main_root);
}

// рекурсивная функция печати элементов поддерева с корнем root (обход ЛКП)

void Tree::Print_2(Node* root){
// явный случай - пустое дерево не печатаем
    if (root==NULL) return;
// сначала печатаем левое поддерево
    Print_2(root->left);
// печатаем значение в корне поддерева
    cout<<(root->info)<<" ";
// печатаем правое поддерево
    Print_2(root->right);
}

// функция-адаптер для алгоритма рекурсивного добавления элемента в дерево

void Tree::Add_2(int info){
// нерекурсивный вызов
    Add_2(info, main_root);
}

// рекурсивная функция добавления элемента в поддерево с корнем root (передается по ссылке, чтобы можно было новый узел сохранить)

void Tree::Add_2(int info, Node*& root){
// если поддерево пустое, создаем единственный узел (адрес сохранится в переменной, ссылка на которую передана в качестве параметра)
    if(root==NULL){
        root = new Node(info); return;
    }

// если значение должно быть в левом поддереве

    if(root->info > info)
// добавляем значение в левое поддерево
        Add_2(info, root->left);
    else
// добавляем значение в правое поддерево
        Add_2(info, root->right);
}

// нерекурсивный вариант функции добавления элемента в дерево
void Tree::Add_1(int info) {
// в пустое дерево добавляется единственный узел
    if(main_root==NULL) {
        main_root = new Node(info); return;
    }
//если дерево не пустое, требуется найти место встави, начиная с корня, пройдя по одной ветви дерева
    Node* cur=main_root;
// движение по дереву будем проводить до получения места вставки - количество шагов в этом случае неизвестно
    while(true) {
        if(cur->info > info)
// добавление производится в левое поддерево
            if(cur->left!=NULL)
// если левое поддерево не пусто, то сдвигаемся на корень левого поддерева
                cur=cur->left;
            else {
// если левое поддерево пусто, найдено место вставки
// создается новый элемент и подцепляется в виде левого потомка
                cur->left=new Node(info); return;
            }
        else
// добавление производится в правое поддерево
        if(cur->right!=NULL)
// если правое поддерево не пусто, то сдвигаемся на корень правого поддерева
            cur=cur->right;
        else {
// если правое поддерево пусто, найдено место вставки
// создается новый элемент и подцепляется в виде правого потомка
            cur->right=new Node(info); return;
        }
    }
}

int main() {
    Tree tree;
    int a[]={7,3,6,8,1,5,2,4,9,10};
    for(int i=0;i<9; i++)
        tree.Add_2(a[i]);
    tree.Print_2();
    cout<<endl;
    tree.NumPeakLevel(4);

   // tree.Stage(3);
    return 0;
}