// 1 task.
// Построить множество M, где 1 принадл. M  и если x принадл. М, то (2х+1), (3х+1) принадл. M
// Переменная n - размерность множетсва
// Элементы множетсва - натурльные неповторяющиеся числа!


#include <iostream>
using namespace std;

int n, M[1000];

// 1 3 4 7 10 9 13 15 22 21 31 19 28 30 35 40 48
//                                 i (1) 63
//                  j (2) 63


int main() {
    setlocale(LC_ALL, "ru");
    int curi=0, curj=0, k=3; int i=1, j=1;
    cout<<"Введите кол-во элементов в множетсве: ";
    cin>>n;
    M[0]=1; M[1]=3; M[2]=4;
    while (k!=n) {
        for (i; i<i+1;i++) {
            curi=M[i]*2+1;
            break;
        }
        for (j; j<j+1;j++) {
            curj=M[j]*3+1;
            break;
        }
        if (curi<curj){
            M[k]=curi;
            i++; k++;
        }
        if (curi>curj) {
            M[k]=curj;
            j++; k++;
        }
        if (curi==curj){
            M[k]=curi;
            i++; j++; k++;
        }
    }
    cout<<"Полученное множество: "<<endl;
    cout<<"( ";
    for(int i=0; i<n; i++){
        cout<<M[i]<<", ";
    }
    cout<<" )";
    return 0;
}

// 1 task complete

// task 2
// Описать класс Граф с весами (длинами) ребер
// - храним кол-во вершин
// - онструкторы + деструкторы
// - ввод графа списков ребер (a, b, w)
// - печать матрицы (?) инциденций
// Задача: найти длину кратчайшего пути м/у двумя веринами